from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
import logging
import tempfile
import os
from PIL import Image
import pytesseract

from src.database import db
from src.utils.translator import translate_text, get_language_name
from src.utils.ocr import extract_text_from_image
from src.config import DEFAULT_LANGUAGE, DEFAULT_INTERFACE_LANGUAGE, SUPPORTED_LANGUAGES, BOT_INTERFACE_LANGUAGES

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω tin nh·∫Øn th√¥ng th∆∞·ªùng"""
    # N·∫øu tin nh·∫Øn l√† t·ª´ k√™nh ho·∫∑c ƒë∆∞·ª£c forward, x·ª≠ l√Ω ri√™ng
    if update.message.forward_from_chat or update.message.forward_from:
        await handle_forwarded_message(update, context)
        return
    
    # L·∫•y th√¥ng tin ng∆∞·ªùi d√πng
    user_id = update.effective_user.id
    user = db.get_user(user_id)
    
    # N·∫øu ng∆∞·ªùi d√πng ch∆∞a t·ªìn t·∫°i, t·∫°o m·ªõi
    if not user:
        # X√°c ƒë·ªãnh ng√¥n ng·ªØ giao ti·∫øp t·ª´ ng√¥n ng·ªØ c·ªßa ng∆∞·ªùi d√πng n·∫øu ƒë∆∞·ª£c h·ªó tr·ª£
        user_lang = update.effective_user.language_code
        interface_lang = user_lang if user_lang in BOT_INTERFACE_LANGUAGES else DEFAULT_INTERFACE_LANGUAGE
        
        user = db.create_user(
            user_id=user_id,
            username=update.effective_user.username,
            first_name=update.effective_user.first_name,
            language_code=DEFAULT_LANGUAGE,
            interface_language=interface_lang
        )
    
    # L·∫•y ng√¥n ng·ªØ d·ªãch v√† giao ti·∫øp c·ªßa ng∆∞·ªùi d√πng
    target_language = user.get("language_code", DEFAULT_LANGUAGE)
    interface_language = user.get("interface_language", DEFAULT_INTERFACE_LANGUAGE)
    
    # Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ c√†i ƒë·∫∑t ng√¥n ng·ªØ ƒë√≠ch ch∆∞a
    if not target_language:
        # T·∫°o n√∫t c√†i ƒë·∫∑t ng√¥n ng·ªØ
        keyboard = [[
            InlineKeyboardButton("C√†i ƒë·∫∑t ng√¥n ng·ªØ / Set language", callback_data="setlang_prompt")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Hi·ªÉn th·ªã th√¥ng b√°o theo ng√¥n ng·ªØ giao ti·∫øp
        if interface_language == "en":
            await update.message.reply_text(
                "‚ö†Ô∏è You haven't set your target translation language yet.\n\n"
                "Please use the /setlang command to set your preferred translation language.",
                reply_markup=reply_markup
            )
        else:
            await update.message.reply_text(
                "‚ö†Ô∏è B·∫°n ch∆∞a c√†i ƒë·∫∑t ng√¥n ng·ªØ d·ªãch m·ª•c ti√™u.\n\n"
                "Vui l√≤ng s·ª≠ d·ª•ng l·ªánh /setlang ƒë·ªÉ c√†i ƒë·∫∑t ng√¥n ng·ªØ d·ªãch ∆∞a th√≠ch c·ªßa b·∫°n.",
                reply_markup=reply_markup
            )
        return
    
    # Ki·ªÉm tra lo·∫°i tin nh·∫Øn
    if update.message.photo:
        # X·ª≠ l√Ω tin nh·∫Øn h√¨nh ·∫£nh
        await handle_photo_message(update, context, target_language)
        return
    elif update.message.video:
        # X·ª≠ l√Ω tin nh·∫Øn video (ch·ªâ d·ªãch caption)
        await handle_video_message(update, context, target_language, interface_language)
        return
    
    # L·∫•y n·ªôi dung tin nh·∫Øn
    text = update.message.text
    
    if not text:
        # Hi·ªÉn th·ªã th√¥ng b√°o theo ng√¥n ng·ªØ giao ti·∫øp
        if interface_language == "en":
            await update.message.reply_text(
                "I can translate text messages, images, or videos with captions. Please send a text message, image, video, or forward a message from another channel/bot."
            )
        else:
            await update.message.reply_text(
                "T√¥i c√≥ th·ªÉ d·ªãch tin nh·∫Øn vƒÉn b·∫£n, h√¨nh ·∫£nh, ho·∫∑c video c√≥ caption. Vui l√≤ng g·ª≠i tin nh·∫Øn vƒÉn b·∫£n, h√¨nh ·∫£nh, video ho·∫∑c forward tin nh·∫Øn t·ª´ k√™nh/bot kh√°c."
            )
        return
    
    # D·ªãch tin nh·∫Øn
    translation = translate_text(text, dest_language=target_language)
    
    # N·∫øu c√≥ l·ªói khi d·ªãch
    if "error" in translation:
        # Hi·ªÉn th·ªã th√¥ng b√°o l·ªói theo ng√¥n ng·ªØ giao ti·∫øp
        if interface_language == "en":
            await update.message.reply_text(
                f"‚ùå An error occurred while translating the message: {translation['error']}"
            )
        else:
            await update.message.reply_text(
                f"‚ùå C√≥ l·ªói x·∫£y ra khi d·ªãch tin nh·∫Øn: {translation['error']}"
            )
        return
    
    # N·∫øu ng√¥n ng·ªØ ngu·ªìn gi·ªëng ng√¥n ng·ªØ ƒë√≠ch
    if translation["source_language"] == target_language:
        # Hi·ªÉn th·ªã th√¥ng b√°o theo ng√¥n ng·ªØ giao ti·∫øp
        target_lang_name = get_language_name(target_language)
        if interface_language == "en":
            await update.message.reply_text(
                f"The message is already in your target language ({target_lang_name})."
            )
        else:
            await update.message.reply_text(
                f"Tin nh·∫Øn ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch c·ªßa b·∫°n ({target_lang_name})."
            )
        return
    
    # L·∫•y t√™n ng√¥n ng·ªØ ƒë·∫ßy ƒë·ªß
    source_lang_name = get_language_name(translation["source_language"])
    target_lang_name = get_language_name(target_language)
    
    # G·ª≠i k·∫øt qu·∫£ d·ªãch
    if interface_language == "en":
        await update.message.reply_text(
            f"üîÑ *Translation from {source_lang_name} to {target_lang_name}:*\n\n{translation['translated_text']}",
            parse_mode="Markdown"
        )
    else:
        await update.message.reply_text(
            f"üîÑ *B·∫£n d·ªãch t·ª´ {source_lang_name} sang {target_lang_name}:*\n\n{translation['translated_text']}",
            parse_mode="Markdown"
        )

async def handle_photo_message(update: Update, context: ContextTypes.DEFAULT_TYPE, target_language):
    """X·ª≠ l√Ω tin nh·∫Øn h√¨nh ·∫£nh"""
    # G·ª≠i tin nh·∫Øn ƒëang x·ª≠ l√Ω
    processing_message = await update.message.reply_text(
        "‚è≥ ƒêang tr√≠ch xu·∫•t vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh..."
    )
    
    # Tr√≠ch xu·∫•t vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh
    text = await extract_text_from_image(update, context)
    
    # N·∫øu kh√¥ng th·ªÉ tr√≠ch xu·∫•t vƒÉn b·∫£n
    if text.startswith("Kh√¥ng th·ªÉ tr√≠ch xu·∫•t") or text.startswith("C√≥ l·ªói x·∫£y ra"):
        await processing_message.edit_text(text)
        return
    
    # C·∫≠p nh·∫≠t tin nh·∫Øn ƒëang x·ª≠ l√Ω
    await processing_message.edit_text(
        f"üìù *VƒÉn b·∫£n tr√≠ch xu·∫•t:*\n\n{text}\n\n‚è≥ ƒêang d·ªãch..."
    )
    
    # D·ªãch vƒÉn b·∫£n
    translation = translate_text(text, dest_language=target_language)
    
    # N·∫øu c√≥ l·ªói khi d·ªãch
    if "error" in translation:
        await processing_message.edit_text(
            f"üìù *VƒÉn b·∫£n tr√≠ch xu·∫•t:*\n\n{text}\n\n‚ùå C√≥ l·ªói x·∫£y ra khi d·ªãch: {translation['error']}"
        )
        return
    
    # N·∫øu ng√¥n ng·ªØ ngu·ªìn gi·ªëng ng√¥n ng·ªØ ƒë√≠ch
    if translation["source_language"] == target_language:
        await processing_message.edit_text(
            f"üìù *VƒÉn b·∫£n tr√≠ch xu·∫•t:*\n\n{text}\n\nVƒÉn b·∫£n ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch ({target_language})."
        )
        return
    
    # G·ª≠i k·∫øt qu·∫£ d·ªãch
    await processing_message.edit_text(
        f"üìù *VƒÉn b·∫£n tr√≠ch xu·∫•t:*\n\n{text}\n\n"
        f"üîÑ *B·∫£n d·ªãch ({translation['source_language']} ‚Üí {target_language}):*\n\n{translation['translated_text']}",
        parse_mode="Markdown"
    )

async def handle_video_message(update: Update, context: ContextTypes.DEFAULT_TYPE, target_language, interface_language):
    """X·ª≠ l√Ω tin nh·∫Øn video (ch·ªâ d·ªãch caption)"""
    # L·∫•y caption c·ªßa video
    caption = update.message.caption
    
    # N·∫øu kh√¥ng c√≥ caption
    if not caption:
        # Hi·ªÉn th·ªã th√¥ng b√°o theo ng√¥n ng·ªØ giao ti·∫øp
        if interface_language == "en":
            await update.message.reply_text(
                "The video doesn't have any caption to translate. I can only translate captions of videos."
            )
        else:
            await update.message.reply_text(
                "Video kh√¥ng c√≥ caption ƒë·ªÉ d·ªãch. T√¥i ch·ªâ c√≥ th·ªÉ d·ªãch caption c·ªßa video."
            )
        return
    
    # D·ªãch caption
    translation = translate_text(caption, dest_language=target_language)
    
    # N·∫øu c√≥ l·ªói khi d·ªãch
    if "error" in translation:
        # Hi·ªÉn th·ªã th√¥ng b√°o l·ªói theo ng√¥n ng·ªØ giao ti·∫øp
        if interface_language == "en":
            await update.message.reply_text(
                f"‚ùå An error occurred while translating the caption: {translation['error']}"
            )
        else:
            await update.message.reply_text(
                f"‚ùå C√≥ l·ªói x·∫£y ra khi d·ªãch caption: {translation['error']}"
            )
        return
    
    # N·∫øu ng√¥n ng·ªØ ngu·ªìn gi·ªëng ng√¥n ng·ªØ ƒë√≠ch
    if translation["source_language"] == target_language:
        # Hi·ªÉn th·ªã th√¥ng b√°o theo ng√¥n ng·ªØ giao ti·∫øp
        if interface_language == "en":
            await update.message.reply_text(
                f"The caption is already in your target language ({get_language_name(target_language)})."
            )
        else:
            await update.message.reply_text(
                f"Caption ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch c·ªßa b·∫°n ({get_language_name(target_language)})."
            )
        return
    
    # L·∫•y t√™n ng√¥n ng·ªØ
    source_lang_name = get_language_name(translation["source_language"])
    target_lang_name = get_language_name(target_language)
    
    # G·ª≠i k·∫øt qu·∫£ d·ªãch
    if interface_language == "en":
        await update.message.reply_text(
            f"üìù *Original Caption:*\n\n{caption}\n\n"
            f"üîÑ *Translation from {source_lang_name} to {target_lang_name}:*\n\n{translation['translated_text']}",
            parse_mode="Markdown"
        )
    else:
        await update.message.reply_text(
            f"üìù *Caption g·ªëc:*\n\n{caption}\n\n"
            f"üîÑ *B·∫£n d·ªãch t·ª´ {source_lang_name} sang {target_lang_name}:*\n\n{translation['translated_text']}",
            parse_mode="Markdown"
        )

async def handle_forwarded_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω tin nh·∫Øn ƒë∆∞·ª£c forward"""
    # L·∫•y th√¥ng tin ng∆∞·ªùi d√πng
    user_id = update.effective_user.id
    user = db.get_user(user_id)
    
    # N·∫øu ng∆∞·ªùi d√πng ch∆∞a t·ªìn t·∫°i, t·∫°o m·ªõi
    if not user:
        # X√°c ƒë·ªãnh ng√¥n ng·ªØ giao ti·∫øp t·ª´ ng√¥n ng·ªØ c·ªßa ng∆∞·ªùi d√πng n·∫øu ƒë∆∞·ª£c h·ªó tr·ª£
        user_lang = update.effective_user.language_code
        interface_lang = user_lang if user_lang in BOT_INTERFACE_LANGUAGES else DEFAULT_INTERFACE_LANGUAGE
        
        user = db.create_user(
            user_id=user_id,
            username=update.effective_user.username,
            first_name=update.effective_user.first_name,
            language_code=DEFAULT_LANGUAGE,
            interface_language=interface_lang
        )
    
    # L·∫•y ng√¥n ng·ªØ d·ªãch v√† giao ti·∫øp c·ªßa ng∆∞·ªùi d√πng
    target_language = user.get("language_code", DEFAULT_LANGUAGE)
    interface_language = user.get("interface_language", DEFAULT_INTERFACE_LANGUAGE)
    
    # L·∫•y th√¥ng tin k√™nh/ng∆∞·ªùi d√πng g·ªëc
    forward_from_chat = update.message.forward_from_chat
    forward_from = update.message.forward_from
    
    # X√°c ƒë·ªãnh ID v√† ti√™u ƒë·ªÅ c·ªßa k√™nh/ng∆∞·ªùi d√πng g·ªëc
    if forward_from_chat:
        # Tin nh·∫Øn ƒë∆∞·ª£c forward t·ª´ k√™nh/nh√≥m
        source_id = str(forward_from_chat.id)
        source_title = forward_from_chat.title or source_id
    elif forward_from:
        # Tin nh·∫Øn ƒë∆∞·ª£c forward t·ª´ ng∆∞·ªùi d√πng
        source_id = str(forward_from.id)
        source_title = forward_from.first_name or source_id
    else:
        # Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ngu·ªìn
        if interface_language == "en":
            await update.message.reply_text(
                "Unable to identify the source of the forwarded message."
            )
        else:
            await update.message.reply_text(
                "Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ngu·ªìn c·ªßa tin nh·∫Øn ƒë∆∞·ª£c forward."
            )
        return
    
    # Ki·ªÉm tra xem k√™nh ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω ch∆∞a
    channel = db.get_channel(source_id)
    is_registered = channel and user_id in channel.get("subscribers", [])
    
    # Ki·ªÉm tra lo·∫°i tin nh·∫Øn
    if update.message.photo:
        # X·ª≠ l√Ω tin nh·∫Øn h√¨nh ·∫£nh ƒë∆∞·ª£c forward
        await handle_forwarded_photo(update, context, target_language, source_id, source_title, is_registered)
        return
    elif update.message.video:
        # X·ª≠ l√Ω tin nh·∫Øn video ƒë∆∞·ª£c forward
        await handle_forwarded_video(update, context, target_language, interface_language, source_id, source_title, is_registered)
        return
    
    # L·∫•y n·ªôi dung tin nh·∫Øn
    text = update.message.text
    
    if not text:
        if interface_language == "en":
            await update.message.reply_text(
                "I can only translate text messages, images, or videos with captions. Please forward a text message, image, or video with caption from another channel/bot."
            )
        else:
            await update.message.reply_text(
                "T√¥i ch·ªâ c√≥ th·ªÉ d·ªãch tin nh·∫Øn vƒÉn b·∫£n, h√¨nh ·∫£nh, ho·∫∑c video c√≥ caption. Vui l√≤ng forward tin nh·∫Øn vƒÉn b·∫£n, h√¨nh ·∫£nh, ho·∫∑c video c√≥ caption t·ª´ k√™nh/bot kh√°c."
            )
        return
    
    # D·ªãch tin nh·∫Øn
    translation = translate_text(text, dest_language=target_language)
    
    # N·∫øu c√≥ l·ªói khi d·ªãch
    if "error" in translation:
        if interface_language == "en":
            await update.message.reply_text(
                f"‚ùå An error occurred while translating the message: {translation['error']}",
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                f"‚ùå C√≥ l·ªói x·∫£y ra khi d·ªãch tin nh·∫Øn: {translation['error']}",
                reply_to_message_id=update.message.message_id
            )
        return
    
    # N·∫øu ng√¥n ng·ªØ ngu·ªìn gi·ªëng ng√¥n ng·ªØ ƒë√≠ch
    if translation["source_language"] == target_language:
        if not is_registered:
            # Hi·ªÉn th·ªã n√∫t ƒëƒÉng k√Ω n·∫øu k√™nh ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω
            keyboard = [[
                InlineKeyboardButton("üìå ƒêƒÉng k√Ω k√™nh n√†y", callback_data=f"register_{source_id}")
            ]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            if interface_language == "en":
                await update.message.reply_text(
                    f"The message is already in the target language ({get_language_name(target_language)}).\n\n"
                    f"Do you want to register the channel {source_title} to automatically translate new messages?",
                    reply_markup=reply_markup,
                    reply_to_message_id=update.message.message_id
                )
            else:
                await update.message.reply_text(
                    f"Tin nh·∫Øn ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch ({get_language_name(target_language)}).\n\n"
                    f"B·∫°n c√≥ mu·ªën ƒëƒÉng k√Ω k√™nh {source_title} ƒë·ªÉ t·ª± ƒë·ªông d·ªãch tin nh·∫Øn m·ªõi?",
                    reply_markup=reply_markup,
                    reply_to_message_id=update.message.message_id
                )
        else:
            if interface_language == "en":
                await update.message.reply_text(
                    f"The message is already in the target language ({get_language_name(target_language)}).",
                    reply_to_message_id=update.message.message_id
                )
            else:
                await update.message.reply_text(
                    f"Tin nh·∫Øn ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch ({get_language_name(target_language)}).",
                    reply_to_message_id=update.message.message_id
                )
        return
    
    # G·ª≠i k·∫øt qu·∫£ d·ªãch
    if not is_registered:
        # Hi·ªÉn th·ªã n√∫t ƒëƒÉng k√Ω n·∫øu k√™nh ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω
        keyboard = [[
            InlineKeyboardButton("üìå ƒêƒÉng k√Ω k√™nh n√†y", callback_data=f"register_{source_id}")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if interface_language == "en":
            await update.message.reply_text(
                f"üîÑ *Translation from {source_title}:*\n\n"
                f"From {get_language_name(translation['source_language'])} to {get_language_name(target_language)}:\n\n"
                f"{translation['translated_text']}",
                parse_mode="Markdown",
                reply_markup=reply_markup,
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                f"üîÑ *B·∫£n d·ªãch t·ª´ {source_title}:*\n\n"
                f"T·ª´ {get_language_name(translation['source_language'])} sang {get_language_name(target_language)}:\n\n"
                f"{translation['translated_text']}",
                parse_mode="Markdown",
                reply_markup=reply_markup,
                reply_to_message_id=update.message.message_id
            )
    else:
        if interface_language == "en":
            await update.message.reply_text(
                f"üîÑ *Translation from {source_title}:*\n\n"
                f"From {get_language_name(translation['source_language'])} to {get_language_name(target_language)}:\n\n"
                f"{translation['translated_text']}",
                parse_mode="Markdown",
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                f"üîÑ *B·∫£n d·ªãch t·ª´ {source_title}:*\n\n"
                f"T·ª´ {get_language_name(translation['source_language'])} sang {get_language_name(target_language)}:\n\n"
                f"{translation['translated_text']}",
                parse_mode="Markdown",
                reply_to_message_id=update.message.message_id
            )

async def handle_forwarded_video(update, context, target_language, interface_language, source_id, source_title, is_registered):
    """X·ª≠ l√Ω tin nh·∫Øn video ƒë∆∞·ª£c forward"""
    # L·∫•y caption c·ªßa video
    caption = update.message.caption
    
    # N·∫øu kh√¥ng c√≥ caption
    if not caption:
        if interface_language == "en":
            await update.message.reply_text(
                "The forwarded video doesn't have any caption to translate.",
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                "Video ƒë∆∞·ª£c forward kh√¥ng c√≥ caption ƒë·ªÉ d·ªãch.",
                reply_to_message_id=update.message.message_id
            )
        return
    
    # D·ªãch caption
    translation = translate_text(caption, dest_language=target_language)
    
    # N·∫øu c√≥ l·ªói khi d·ªãch
    if "error" in translation:
        if interface_language == "en":
            await update.message.reply_text(
                f"‚ùå An error occurred while translating the caption: {translation['error']}",
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                f"‚ùå C√≥ l·ªói x·∫£y ra khi d·ªãch caption: {translation['error']}",
                reply_to_message_id=update.message.message_id
            )
        return
    
    # N·∫øu ng√¥n ng·ªØ ngu·ªìn gi·ªëng ng√¥n ng·ªØ ƒë√≠ch
    if translation["source_language"] == target_language:
        if not is_registered:
            # Hi·ªÉn th·ªã n√∫t ƒëƒÉng k√Ω n·∫øu k√™nh ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω
            keyboard = [[
                InlineKeyboardButton("üìå ƒêƒÉng k√Ω k√™nh n√†y", callback_data=f"register_{source_id}")
            ]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            if interface_language == "en":
                await update.message.reply_text(
                    f"The caption is already in the target language ({get_language_name(target_language)}).\n\n"
                    f"Do you want to register the channel {source_title} to automatically translate new messages?",
                    reply_markup=reply_markup,
                    reply_to_message_id=update.message.message_id
                )
            else:
                await update.message.reply_text(
                    f"Caption ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch ({get_language_name(target_language)}).\n\n"
                    f"B·∫°n c√≥ mu·ªën ƒëƒÉng k√Ω k√™nh {source_title} ƒë·ªÉ t·ª± ƒë·ªông d·ªãch tin nh·∫Øn m·ªõi?",
                    reply_markup=reply_markup,
                    reply_to_message_id=update.message.message_id
                )
        else:
            if interface_language == "en":
                await update.message.reply_text(
                    f"The caption is already in the target language ({get_language_name(target_language)}).",
                    reply_to_message_id=update.message.message_id
                )
            else:
                await update.message.reply_text(
                    f"Caption ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch ({get_language_name(target_language)}).",
                    reply_to_message_id=update.message.message_id
                )
        return
    
    # G·ª≠i k·∫øt qu·∫£ d·ªãch
    if not is_registered:
        # Hi·ªÉn th·ªã n√∫t ƒëƒÉng k√Ω n·∫øu k√™nh ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω
        keyboard = [[
            InlineKeyboardButton("üìå ƒêƒÉng k√Ω k√™nh n√†y", callback_data=f"register_{source_id}")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if interface_language == "en":
            await update.message.reply_text(
                f"üìù *Original Caption from {source_title}:*\n\n{caption}\n\n"
                f"üîÑ *Translation ({translation['source_language']} ‚Üí {target_language}):*\n\n{translation['translated_text']}\n\n"
                f"Do you want to register this channel to automatically translate new messages?",
                parse_mode="Markdown",
                reply_markup=reply_markup,
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                f"üìù *Caption g·ªëc t·ª´ {source_title}:*\n\n{caption}\n\n"
                f"üîÑ *B·∫£n d·ªãch ({translation['source_language']} ‚Üí {target_language}):*\n\n{translation['translated_text']}\n\n"
                f"B·∫°n c√≥ mu·ªën ƒëƒÉng k√Ω k√™nh n√†y ƒë·ªÉ t·ª± ƒë·ªông d·ªãch tin nh·∫Øn m·ªõi?",
                parse_mode="Markdown",
                reply_markup=reply_markup,
                reply_to_message_id=update.message.message_id
            )
    else:
        if interface_language == "en":
            await update.message.reply_text(
                f"üìù *Original Caption from {source_title}:*\n\n{caption}\n\n"
                f"üîÑ *Translation ({translation['source_language']} ‚Üí {target_language}):*\n\n{translation['translated_text']}",
                parse_mode="Markdown",
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                f"üìù *Caption g·ªëc t·ª´ {source_title}:*\n\n{caption}\n\n"
                f"üîÑ *B·∫£n d·ªãch ({translation['source_language']} ‚Üí {target_language}):*\n\n{translation['translated_text']}",
                parse_mode="Markdown",
                reply_to_message_id=update.message.message_id
            )

async def handle_forwarded_photo(update, context, target_language, source_id, source_title, is_registered):
    """X·ª≠ l√Ω tin nh·∫Øn h√¨nh ·∫£nh ƒë∆∞·ª£c forward"""
    # G·ª≠i tin nh·∫Øn ƒëang x·ª≠ l√Ω
    processing_message = await update.message.reply_text(
        "‚è≥ ƒêang tr√≠ch xu·∫•t vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh...",
        reply_to_message_id=update.message.message_id
    )
    
    # Ki·ªÉm tra xem tin nh·∫Øn c√≥ caption kh√¥ng
    caption = update.message.caption
    
    # Tr√≠ch xu·∫•t vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh
    text = await extract_text_from_image(update, context)
    
    # N·∫øu kh√¥ng th·ªÉ tr√≠ch xu·∫•t vƒÉn b·∫£n v√† kh√¥ng c√≥ caption
    if (text.startswith("Kh√¥ng th·ªÉ tr√≠ch xu·∫•t") or text.startswith("C√≥ l·ªói x·∫£y ra")) and not caption:
        await processing_message.edit_text(text)
        return
    
    # N·∫øu kh√¥ng th·ªÉ tr√≠ch xu·∫•t vƒÉn b·∫£n nh∆∞ng c√≥ caption
    if (text.startswith("Kh√¥ng th·ªÉ tr√≠ch xu·∫•t") or text.startswith("C√≥ l·ªói x·∫£y ra")) and caption:
        text = ""  # ƒê·∫∑t text th√†nh chu·ªói r·ªóng ƒë·ªÉ ch·ªâ d·ªãch caption
    
    # Chu·∫©n b·ªã n·ªôi dung ƒë·ªÉ d·ªãch
    content_to_translate = ""
    
    # N·∫øu c√≥ vƒÉn b·∫£n tr√≠ch xu·∫•t t·ª´ h√¨nh ·∫£nh
    if text and not text.startswith("Kh√¥ng th·ªÉ tr√≠ch xu·∫•t") and not text.startswith("C√≥ l·ªói x·∫£y ra"):
        content_to_translate += f"üìù *VƒÉn b·∫£n tr√≠ch xu·∫•t t·ª´ h√¨nh ·∫£nh c·ªßa {source_title}:*\n\n{text}\n\n"
    
    # N·∫øu c√≥ caption
    if caption:
        content_to_translate += f"üìù *Caption t·ª´ {source_title}:*\n\n{caption}\n\n"
    
    # C·∫≠p nh·∫≠t tin nh·∫Øn ƒëang x·ª≠ l√Ω
    await processing_message.edit_text(
        f"{content_to_translate}‚è≥ ƒêang d·ªãch..."
    )
    
    # D·ªãch vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh (n·∫øu c√≥)
    image_translation = None
    if text and not text.startswith("Kh√¥ng th·ªÉ tr√≠ch xu·∫•t") and not text.startswith("C√≥ l·ªói x·∫£y ra"):
        image_translation = translate_text(text, dest_language=target_language)
    
    # D·ªãch caption (n·∫øu c√≥)
    caption_translation = None
    if caption:
        caption_translation = translate_text(caption, dest_language=target_language)
    
    # Chu·∫©n b·ªã k·∫øt qu·∫£ d·ªãch
    translation_result = ""
    
    # Th√™m k·∫øt qu·∫£ d·ªãch vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh (n·∫øu c√≥)
    if image_translation and "error" not in image_translation:
        if image_translation["source_language"] != target_language:
            translation_result += f"üîÑ *B·∫£n d·ªãch vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh ({image_translation['source_language']} ‚Üí {target_language}):*\n\n{image_translation['translated_text']}\n\n"
        else:
            translation_result += f"üìù *VƒÉn b·∫£n tr√≠ch xu·∫•t t·ª´ h√¨nh ·∫£nh ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch ({target_language})*\n\n"
    elif image_translation and "error" in image_translation:
        translation_result += f"‚ùå C√≥ l·ªói x·∫£y ra khi d·ªãch vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh: {image_translation['error']}\n\n"
    
    # Th√™m k·∫øt qu·∫£ d·ªãch caption (n·∫øu c√≥)
    if caption_translation and "error" not in caption_translation:
        if caption_translation["source_language"] != target_language:
            translation_result += f"üîÑ *B·∫£n d·ªãch caption ({caption_translation['source_language']} ‚Üí {target_language}):*\n\n{caption_translation['translated_text']}"
        else:
            translation_result += f"üìù *Caption ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch ({target_language})*"
    elif caption_translation and "error" in caption_translation:
        translation_result += f"‚ùå C√≥ l·ªói x·∫£y ra khi d·ªãch caption: {caption_translation['error']}"
    
    # N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£ d·ªãch n√†o
    if not translation_result:
        await processing_message.edit_text(
            "‚ùå Kh√¥ng th·ªÉ d·ªãch n·ªôi dung. Vui l√≤ng th·ª≠ l·∫°i v·ªõi h√¨nh ·∫£nh kh√°c ho·∫∑c th√™m caption."
        )
        return
    
    # G·ª≠i k·∫øt qu·∫£ d·ªãch
    if not is_registered:
        # Hi·ªÉn th·ªã n√∫t ƒëƒÉng k√Ω n·∫øu k√™nh ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω
        keyboard = [[
            InlineKeyboardButton("üìå ƒêƒÉng k√Ω k√™nh n√†y", callback_data=f"register_{source_id}")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await processing_message.edit_text(
            f"{content_to_translate}{translation_result}\n\n"
            f"B·∫°n c√≥ mu·ªën ƒëƒÉng k√Ω k√™nh n√†y ƒë·ªÉ t·ª± ƒë·ªông d·ªãch tin nh·∫Øn m·ªõi?",
            parse_mode="Markdown",
            reply_markup=reply_markup
        )
    else:
        await processing_message.edit_text(
            f"{content_to_translate}{translation_result}",
            parse_mode="Markdown"
        )

async def handle_channel_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω tin nh·∫Øn m·ªõi t·ª´ k√™nh"""
    try:
        # L·∫•y th√¥ng tin k√™nh
        channel_id = str(update.channel_post.chat.id)
        channel_title = update.channel_post.chat.title
        
        logging.info(f"Received new message from channel {channel_title} ({channel_id})")
        logging.info(f"Message type: {update.channel_post.type}")
        logging.info(f"Message ID: {update.channel_post.message_id}")
        
        # L·∫•y danh s√°ch ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng k√Ω k√™nh n√†y
        registered_users = db.get_channel_users(channel_id)
        
        if not registered_users:
            logging.info(f"No registered users for channel {channel_title} ({channel_id})")
            return
        
        logging.info(f"Found {len(registered_users)} registered users for channel {channel_title} ({channel_id})")
        
        # L·∫•y n·ªôi dung tin nh·∫Øn
        message = update.channel_post
        
        # X·ª≠ l√Ω tin nh·∫Øn vƒÉn b·∫£n
        if message.text:
            text = message.text
            logging.info(f"Processing text message from channel {channel_title} ({channel_id})")
        # X·ª≠ l√Ω tin nh·∫Øn h√¨nh ·∫£nh c√≥ caption
        elif message.caption:
            text = message.caption
            logging.info(f"Processing image caption from channel {channel_title} ({channel_id})")
        else:
            logging.info(f"No text content to translate from channel {channel_title} ({channel_id})")
            return
        
        # Nh√≥m ng∆∞·ªùi d√πng theo ng√¥n ng·ªØ ƒë√≠ch
        users_by_language = {}
        for user in registered_users:
            target_language = user.get("language_code", DEFAULT_LANGUAGE)
            if target_language not in users_by_language:
                users_by_language[target_language] = []
            users_by_language[target_language].append(user)
        
        logging.info(f"Grouped users by target language: {list(users_by_language.keys())}")
        
        # D·ªãch v√† g·ª≠i tin nh·∫Øn cho t·ª´ng nh√≥m ng√¥n ng·ªØ
        for target_language, users in users_by_language.items():
            try:
                # D·ªãch n·ªôi dung m·ªôt l·∫ßn cho m·ªói ng√¥n ng·ªØ ƒë√≠ch
                translation = translate_text(text, dest_language=target_language)
                logging.info(f"Translated text to {target_language}")
                
                # G·ª≠i tin nh·∫Øn cho t·∫•t c·∫£ ng∆∞·ªùi d√πng trong nh√≥m ng√¥n ng·ªØ
                for user in users:
                    try:
                        user_id = user.get("user_id")
                        interface_language = user.get("interface_language", DEFAULT_INTERFACE_LANGUAGE)
                        
                        logging.info(f"Sending message to user {user_id} in {interface_language}")
                        
                        # T·∫°o tin nh·∫Øn ph·∫£n h·ªìi
                        if interface_language == "en":
                            response = f"üì¢ *New message from {channel_title}*\n\n"
                            response += f"*Original:*\n{text}\n\n"
                            response += f"*Translation:*\n{translation['translated_text']}"
                        else:
                            response = f"üì¢ *Tin nh·∫Øn m·ªõi t·ª´ {channel_title}*\n\n"
                            response += f"*N·ªôi dung g·ªëc:*\n{text}\n\n"
                            response += f"*B·∫£n d·ªãch:*\n{translation['translated_text']}"
                        
                        # G·ª≠i tin nh·∫Øn ƒë√£ d·ªãch tr·ª±c ti·∫øp cho ng∆∞·ªùi d√πng trong chat ri√™ng
                        await context.bot.send_message(
                            chat_id=user_id,  # G·ª≠i ƒë·∫øn user_id thay v√¨ channel_id
                            text=response,
                            parse_mode="Markdown"
                        )
                        logging.info(f"Successfully sent translated message to user {user_id}")
                        
                    except Exception as e:
                        logging.error(f"Error sending message to user {user_id}: {e}")
                        continue
                        
            except Exception as e:
                logging.error(f"Error processing translation for language {target_language}: {e}")
                continue
                
    except Exception as e:
        logging.error(f"Error handling channel post: {e}")

async def handle_channel_photo(update, context, channel):
    """X·ª≠ l√Ω tin nh·∫Øn h√¨nh ·∫£nh t·ª´ k√™nh"""
    channel_id = str(update.channel_post.chat.id)
    
    # L·∫•y danh s√°ch ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng k√Ω k√™nh
    subscribers = channel.get("subscribers", [])
    
    # Ki·ªÉm tra xem tin nh·∫Øn c√≥ caption kh√¥ng
    caption = update.channel_post.caption
    
    # Tr√≠ch xu·∫•t vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh
    try:
        # L·∫•y file ·∫£nh v·ªõi k√≠ch th∆∞·ªõc l·ªõn nh·∫•t
        photo = update.channel_post.photo[-1]
        
        # T·∫°o th∆∞ m·ª•c t·∫°m ƒë·ªÉ l∆∞u ·∫£nh
        with tempfile.TemporaryDirectory() as temp_dir:
            # T·∫°o ƒë∆∞·ªùng d·∫´n ƒë·∫øn file ·∫£nh
            photo_path = os.path.join(temp_dir, f"{photo.file_id}.jpg")
            
            # T·∫£i file ·∫£nh
            photo_file = await context.bot.get_file(photo.file_id)
            await photo_file.download_to_drive(photo_path)
            
            # M·ªü ·∫£nh b·∫±ng Pillow
            image = Image.open(photo_path)
            
            # S·ª≠ d·ª•ng pytesseract ƒë·ªÉ tr√≠ch xu·∫•t vƒÉn b·∫£n
            text = pytesseract.image_to_string(image)
            
            # X√≥a kho·∫£ng tr·∫Øng th·ª´a v√† ki·ªÉm tra n·∫øu vƒÉn b·∫£n r·ªóng
            text = text.strip()
            
            # N·∫øu kh√¥ng c√≥ vƒÉn b·∫£n tr√≠ch xu·∫•t v√† kh√¥ng c√≥ caption, b·ªè qua
            if not text and not caption:
                return
            
            # D·ªãch tin nh·∫Øn cho t·ª´ng ng∆∞·ªùi d√πng
            for user_id in subscribers:
                # L·∫•y th√¥ng tin ng∆∞·ªùi d√πng
                user = db.get_user(user_id)
                
                if not user:
                    continue
                
                # L·∫•y ng√¥n ng·ªØ d·ªãch v√† giao ti·∫øp c·ªßa ng∆∞·ªùi d√πng
                target_language = user.get("language_code", DEFAULT_LANGUAGE)
                interface_language = user.get("interface_language", DEFAULT_INTERFACE_LANGUAGE)
                
                # Chu·∫©n b·ªã n·ªôi dung ƒë·ªÉ hi·ªÉn th·ªã
                content_to_display = ""
                translation_result = ""
                
                # D·ªãch vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh (n·∫øu c√≥)
                if text:
                    content_to_display += f"üìù *VƒÉn b·∫£n tr√≠ch xu·∫•t t·ª´ h√¨nh ·∫£nh:*\n\n{text}\n\n"
                    image_translation = translate_text(text, dest_language=target_language)
                    
                    # N·∫øu d·ªãch th√†nh c√¥ng v√† ng√¥n ng·ªØ ngu·ªìn kh√°c ng√¥n ng·ªØ ƒë√≠ch
                    if "error" not in image_translation and image_translation["source_language"] != target_language:
                        translation_result += f"üîÑ *B·∫£n d·ªãch vƒÉn b·∫£n t·ª´ h√¨nh ·∫£nh ({image_translation['source_language']} ‚Üí {target_language}):*\n\n{image_translation['translated_text']}\n\n"
                
                # D·ªãch caption (n·∫øu c√≥)
                if caption:
                    content_to_display += f"üìù *Caption:*\n\n{caption}\n\n"
                    caption_translation = translate_text(caption, dest_language=target_language)
                    
                    # N·∫øu d·ªãch th√†nh c√¥ng v√† ng√¥n ng·ªØ ngu·ªìn kh√°c ng√¥n ng·ªØ ƒë√≠ch
                    if "error" not in caption_translation and caption_translation["source_language"] != target_language:
                        translation_result += f"üîÑ *B·∫£n d·ªãch caption ({caption_translation['source_language']} ‚Üí {target_language}):*\n\n{caption_translation['translated_text']}"
                
                # N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£ d·ªãch n√†o, b·ªè qua
                if not translation_result:
                    continue
                
                # G·ª≠i k·∫øt qu·∫£ d·ªãch cho ng∆∞·ªùi d√πng
                try:
                    # G·ª≠i h√¨nh ·∫£nh g·ªëc
                    sent_photo = await context.bot.send_photo(
                        chat_id=user_id,
                        photo=photo.file_id,
                        caption=f"üìù *H√¨nh ·∫£nh t·ª´ {channel.get('title', channel_id)}*",
                        parse_mode="Markdown"
                    )
                    
                    # G·ª≠i vƒÉn b·∫£n tr√≠ch xu·∫•t v√† b·∫£n d·ªãch
                    await context.bot.send_message(
                        chat_id=user_id,
                        text=f"{content_to_display}{translation_result}",
                        parse_mode="Markdown",
                        reply_to_message_id=sent_photo.message_id
                    )
                except Exception as e:
                    logging.error(f"L·ªói khi g·ª≠i tin nh·∫Øn ƒë·∫øn ng∆∞·ªùi d√πng {user_id}: {e}")
    except Exception as e:
        logging.error(f"L·ªói khi x·ª≠ l√Ω h√¨nh ·∫£nh t·ª´ k√™nh: {e}")
        return

async def handle_channel_video(update, context, channel):
    """X·ª≠ l√Ω tin nh·∫Øn video t·ª´ k√™nh"""
    channel_id = str(update.channel_post.chat.id)
    
    # L·∫•y danh s√°ch ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng k√Ω k√™nh
    subscribers = channel.get("subscribers", [])
    
    # L·∫•y caption c·ªßa video
    caption = update.channel_post.caption
    
    # N·∫øu kh√¥ng c√≥ caption, b·ªè qua
    if not caption:
        return
    
    # D·ªãch tin nh·∫Øn cho t·ª´ng ng∆∞·ªùi d√πng
    for user_id in subscribers:
        # L·∫•y th√¥ng tin ng∆∞·ªùi d√πng
        user = db.get_user(user_id)
        
        if not user:
            continue
        
        # L·∫•y ng√¥n ng·ªØ d·ªãch v√† giao ti·∫øp c·ªßa ng∆∞·ªùi d√πng
        target_language = user.get("language_code", DEFAULT_LANGUAGE)
        interface_language = user.get("interface_language", DEFAULT_INTERFACE_LANGUAGE)
        
        # D·ªãch caption
        translation = translate_text(caption, dest_language=target_language)
        
        # N·∫øu c√≥ l·ªói khi d·ªãch ho·∫∑c ng√¥n ng·ªØ ngu·ªìn gi·ªëng ng√¥n ng·ªØ ƒë√≠ch, b·ªè qua
        if "error" in translation or translation["source_language"] == target_language:
            continue
        
        # G·ª≠i k·∫øt qu·∫£ d·ªãch cho ng∆∞·ªùi d√πng
        try:
            # G·ª≠i video g·ªëc
            sent_video = await context.bot.send_video(
                chat_id=user_id,
                video=update.channel_post.video.file_id,
                caption=f"üìù *Video t·ª´ {channel.get('title', channel_id)}*",
                parse_mode="Markdown"
            )
            
            # G·ª≠i caption v√† b·∫£n d·ªãch
            if interface_language == "en":
                await context.bot.send_message(
                    chat_id=user_id,
                    text=f"üìù *Original Caption:*\n\n{caption}\n\n"
                    f"üîÑ *Translation ({translation['source_language']} ‚Üí {target_language}):*\n\n{translation['translated_text']}",
                    parse_mode="Markdown",
                    reply_to_message_id=sent_video.message_id
                )
            else:
                await context.bot.send_message(
                    chat_id=user_id,
                    text=f"üìù *Caption g·ªëc:*\n\n{caption}\n\n"
                    f"üîÑ *B·∫£n d·ªãch ({translation['source_language']} ‚Üí {target_language}):*\n\n{translation['translated_text']}",
                    parse_mode="Markdown",
                    reply_to_message_id=sent_video.message_id
                )
        except Exception as e:
            logging.error(f"L·ªói khi g·ª≠i tin nh·∫Øn ƒë·∫øn ng∆∞·ªùi d√πng {user_id}: {e}")

async def register_channel_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """X·ª≠ l√Ω nh·∫≠p l·ªánh ƒëƒÉng k√Ω k√™nh"""
    # L·∫•y th√¥ng tin ng∆∞·ªùi d√πng
    user_id = update.effective_user.id
    user = db.get_user(user_id)
    
    if not user:
        # N·∫øu ng∆∞·ªùi d√πng ch∆∞a t·ªìn t·∫°i, t·∫°o m·ªõi
        user_lang = update.effective_user.language_code
        interface_lang = user_lang if user_lang in BOT_INTERFACE_LANGUAGES else DEFAULT_INTERFACE_LANGUAGE
        
        user = db.create_user(
            user_id=user_id,
            username=update.effective_user.username,
            first_name=update.effective_user.first_name,
            language_code=DEFAULT_LANGUAGE,
            interface_language=interface_lang
        )
    
    # L·∫•y ng√¥n ng·ªØ d·ªãch v√† giao ti·∫øp c·ªßa ng∆∞·ªùi d√πng
    target_language = user.get("language_code", DEFAULT_LANGUAGE)
    interface_language = user.get("interface_language", DEFAULT_INTERFACE_LANGUAGE)
    
    # Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng nh·∫≠p l·ªánh kh√°c
    if channel_id.startswith('/'):
        # N·∫øu l√† l·ªánh, tho√°t kh·ªèi ch·∫ø ƒë·ªô ƒëƒÉng k√Ω
        if interface_language == "en":
            await update.message.reply_text(
                "Registration canceled. Processing your command..."
            )
        else:
            await update.message.reply_text(
                "ƒê√£ h·ªßy ƒëƒÉng k√Ω. ƒêang x·ª≠ l√Ω l·ªánh c·ªßa b·∫°n..."
            )
        
        # X√≥a tr·∫°ng th√°i ƒëƒÉng k√Ω k√™nh
        context.user_data.pop('register_command', None)
        return ConversationHandler.END

    # Ki·ªÉm tra xem k√™nh ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω ch∆∞a
    channel = db.get_channel(channel_id)
    is_registered = channel and user_id in channel.get("subscribers", [])
    
    # Ki·ªÉm tra lo·∫°i tin nh·∫Øn
    if update.message.photo:
        # X·ª≠ l√Ω tin nh·∫Øn h√¨nh ·∫£nh ƒë∆∞·ª£c forward
        await handle_forwarded_photo(update, context, target_language, channel_id, channel.get('title', channel_id), is_registered)
        return
    elif update.message.video:
        # X·ª≠ l√Ω tin nh·∫Øn video ƒë∆∞·ª£c forward
        await handle_forwarded_video(update, context, target_language, interface_language, channel_id, channel.get('title', channel_id), is_registered)
        return
    
    # L·∫•y n·ªôi dung tin nh·∫Øn
    text = update.message.text
    
    if not text:
        if interface_language == "en":
            await update.message.reply_text(
                "I can only translate text messages, images, or videos with captions. Please forward a text message, image, or video with caption from another channel/bot."
            )
        else:
            await update.message.reply_text(
                "T√¥i ch·ªâ c√≥ th·ªÉ d·ªãch tin nh·∫Øn vƒÉn b·∫£n, h√¨nh ·∫£nh, ho·∫∑c video c√≥ caption. Vui l√≤ng forward tin nh·∫Øn vƒÉn b·∫£n, h√¨nh ·∫£nh, ho·∫∑c video c√≥ caption t·ª´ k√™nh/bot kh√°c."
            )
        return
    
    # D·ªãch tin nh·∫Øn
    translation = translate_text(text, dest_language=target_language)
    
    # N·∫øu c√≥ l·ªói khi d·ªãch
    if "error" in translation:
        if interface_language == "en":
            await update.message.reply_text(
                f"‚ùå An error occurred while translating the message: {translation['error']}",
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                f"‚ùå C√≥ l·ªói x·∫£y ra khi d·ªãch tin nh·∫Øn: {translation['error']}",
                reply_to_message_id=update.message.message_id
            )
        return
    
    # N·∫øu ng√¥n ng·ªØ ngu·ªìn gi·ªëng ng√¥n ng·ªØ ƒë√≠ch
    if translation["source_language"] == target_language:
        if not is_registered:
            # Hi·ªÉn th·ªã n√∫t ƒëƒÉng k√Ω n·∫øu k√™nh ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω
            keyboard = [[
                InlineKeyboardButton("üìå ƒêƒÉng k√Ω k√™nh n√†y", callback_data=f"register_{channel_id}")
            ]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            if interface_language == "en":
                await update.message.reply_text(
                    f"The message is already in the target language ({get_language_name(target_language)}).\n\n"
                    f"Do you want to register the channel {channel.get('title', channel_id)} to automatically translate new messages?",
                    reply_markup=reply_markup,
                    reply_to_message_id=update.message.message_id
                )
            else:
                await update.message.reply_text(
                    f"Tin nh·∫Øn ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch ({get_language_name(target_language)}).\n\n"
                    f"B·∫°n c√≥ mu·ªën ƒëƒÉng k√Ω k√™nh {channel.get('title', channel_id)} ƒë·ªÉ t·ª± ƒë·ªông d·ªãch tin nh·∫Øn m·ªõi?",
                    reply_markup=reply_markup,
                    reply_to_message_id=update.message.message_id
                )
        else:
            if interface_language == "en":
                await update.message.reply_text(
                    f"The message is already in the target language ({get_language_name(target_language)}).",
                    reply_to_message_id=update.message.message_id
                )
            else:
                await update.message.reply_text(
                    f"Tin nh·∫Øn ƒë√£ ·ªü ng√¥n ng·ªØ ƒë√≠ch ({get_language_name(target_language)}).",
                    reply_to_message_id=update.message.message_id
                )
        return
    
    # G·ª≠i k·∫øt qu·∫£ d·ªãch
    if not is_registered:
        # Hi·ªÉn th·ªã n√∫t ƒëƒÉng k√Ω n·∫øu k√™nh ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω
        keyboard = [[
            InlineKeyboardButton("üìå ƒêƒÉng k√Ω k√™nh n√†y", callback_data=f"register_{channel_id}")
        ]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if interface_language == "en":
            await update.message.reply_text(
                f"üîÑ *Translation from {channel.get('title', channel_id)}:*\n\n"
                f"From {get_language_name(translation['source_language'])} to {get_language_name(target_language)}:\n\n"
                f"{translation['translated_text']}",
                parse_mode="Markdown",
                reply_markup=reply_markup,
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                f"üîÑ *B·∫£n d·ªãch t·ª´ {channel.get('title', channel_id)}:*\n\n"
                f"T·ª´ {get_language_name(translation['source_language'])} sang {get_language_name(target_language)}:\n\n"
                f"{translation['translated_text']}",
                parse_mode="Markdown",
                reply_markup=reply_markup,
                reply_to_message_id=update.message.message_id
            )
    else:
        if interface_language == "en":
            await update.message.reply_text(
                f"üîÑ *Translation from {channel.get('title', channel_id)}:*\n\n"
                f"From {get_language_name(translation['source_language'])} to {get_language_name(target_language)}:\n\n"
                f"{translation['translated_text']}",
                parse_mode="Markdown",
                reply_to_message_id=update.message.message_id
            )
        else:
            await update.message.reply_text(
                f"üîÑ *B·∫£n d·ªãch t·ª´ {channel.get('title', channel_id)}:*\n\n"
                f"T·ª´ {get_language_name(translation['source_language'])} sang {get_language_name(target_language)}:\n\n"
                f"{translation['translated_text']}",
                parse_mode="Markdown",
                reply_to_message_id=update.message.message_id
            )

    # X√≥a tr·∫°ng th√°i ƒëƒÉng k√Ω k√™nh
    context.user_data.pop('register_command', None)
    return ConversationHandler.END 